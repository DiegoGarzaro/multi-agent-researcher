"""Multi-agent research system for generating articles with web search.

This module orchestrates a multi-agent system that conducts web research,
writes articles, and performs editorial review with revision loops.
"""

import json
import os
from datetime import datetime
from pathlib import Path

from dotenv import load_dotenv

from agno.agent import Agent
from agno.team import Team
from agno.workflow import Workflow, Step, StepInput, StepOutput
from agno.models.openai import OpenAIChat

from agno.tools.duckduckgo import DuckDuckGoTools
from agno.tools.trafilatura import TrafilaturaTools

from ai_prompts import (
    RESEARCH_INSTRUCTIONS,
    WRITER_INSTRUCTIONS,
    EDITOR_INSTRUCTIONS
)

# Load environment variables from .env file
load_dotenv()

# Create agents_log directory if it doesn't exist
AGENTS_LOG_DIR = Path("agents_log")
AGENTS_LOG_DIR.mkdir(exist_ok=True)

# Load OpenAI model configurations from environment variables
RESEARCHER_MODEL = os.getenv("RESEARCHER_MODEL", "gpt-4o-mini")
WRITER_MODEL = os.getenv("WRITER_MODEL", "gpt-4o-mini")
EDITOR_MODEL = os.getenv("EDITOR_MODEL", "gpt-4o-mini")


def log_agent_execution(
    agent_name: str,
    input_data: str,
    output_data: str,
    round_number: int = 0,
    step: str = "initial"
) -> None:
    """Log agent execution details to a file in the agents_log directory.

    Args:
        agent_name: The name of the agent (e.g., "Researcher", "Writer", "Editor").
        input_data: The input provided to the agent.
        output_data: The output generated by the agent.
        round_number: The revision round number (0 for initial execution).
        step: The step identifier (e.g., "initial", "revision", "final").

    Returns:
        None
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"{timestamp}_{agent_name}_round{round_number}_{step}.json"
    log_path = AGENTS_LOG_DIR / log_filename

    log_data = {
        "timestamp": datetime.now().isoformat(),
        "agent_name": agent_name,
        "round_number": round_number,
        "step": step,
        "input": input_data,
        "output": output_data,
    }

    log_path.write_text(json.dumps(log_data, indent=2, ensure_ascii=False), encoding="utf-8")


# Agents
def build_researcher() -> Agent:
    """Build and configure the Researcher agent.

    The Researcher agent is responsible for conducting web searches and
    extracting reliable sources to create a research brief.

    The model used is configured via the RESEARCHER_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Researcher agent with web search and extraction tools.
    """
    tools = [
        DuckDuckGoTools(),
        TrafilaturaTools(),
    ]
    return Agent(
        name="Researcher",
        role="Web search & source extraction",
        model=OpenAIChat(id=RESEARCHER_MODEL),
        tools=tools,
        instructions=RESEARCH_INSTRUCTIONS,
        markdown=True,
    )


def build_writer() -> Agent:
    """Build and configure the Writer agent.

    The Writer agent transforms research briefs into compelling,
    persuasive articles in Portuguese (PT-BR) using marketing techniques.

    The model used is configured via the WRITER_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Writer agent specialized in copywriting.
    """
    return Agent(
        name="Writer",
        role="Organize research, draft the article and translator",
        model=OpenAIChat(id=WRITER_MODEL),
        instructions=WRITER_INSTRUCTIONS,
        markdown=True,
    )


def build_editor() -> Agent:
    """Build and configure the Editor agent.

    The Editor agent reviews articles for accuracy, quality, marketing
    effectiveness, and PT-BR language compliance.

    The model used is configured via the EDITOR_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Editor agent for quality control and fact-checking.
    """
    return Agent(
        name="Editor",
        role="Critically review and request revisions",
        model=OpenAIChat(id=EDITOR_MODEL),
        instructions=EDITOR_INSTRUCTIONS,
        markdown=True,
    )


# Workflow (orchestrator)
def assemble_team() -> Team:
    """Assemble a multi-agent team for research and writing tasks.

    Creates a team with Researcher, Writer, and Editor agents.
    The Editor acts as the team leader and can coordinate with other members.

    Args:
        None

    Returns:
        Team: Configured team with all three agents (Researcher, Writer, Editor).
    """
    researcher = build_researcher()
    writer = build_writer()
    editor = build_editor()
    return Team(
        name="Research & Writing Team",
        members=[researcher, writer, editor],
        # By default, the team leader coordinates; we'll still drive via Workflow.
        markdown=True,
    )

def research_step_fn(step_input: StepInput, round_number: int = 0) -> StepOutput:
    """Run the Researcher to produce a research brief.

    Args:
        step_input: The input containing the topic to research.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The research brief content.
    """
    topic = step_input.input
    researcher = build_researcher()

    prompt = (
        f"Tópico: {topic}\n"
        "Tarefa: Realize uma pesquisa profunda na web e produza o relatório de pesquisa conforme instruído."
    )

    result = researcher.run(prompt)

    # Extract only the content from RunOutput object
    brief_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Researcher",
        input_data=prompt,
        output_data=brief_content,
        round_number=round_number,
        step="research"
    )

    return StepOutput(content=brief_content)

def write_step_fn(step_input: StepInput, topic: str = "", round_number: int = 0) -> StepOutput:
    """Run the Writer to draft an article from the research brief.

    Args:
        step_input: The input containing the research brief.
        topic: The topic for the article.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The draft article content.
    """
    brief = step_input.previous_step_outputs or step_input.input
    writer = build_writer()

    prompt = (
        f"Escreva um artigo sobre: {topic}\n\n"
        f"Aqui está o relatório de pesquisa (use-o estritamente, mantenha a numeração das fontes):\n\n{brief}"
    )

    result = writer.run(prompt)

    # Extract only the content from RunOutput object
    draft_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Writer",
        input_data=prompt,
        output_data=draft_content,
        round_number=round_number,
        step="write"
    )

    return StepOutput(content=draft_content)

def edit_step_fn(step_input: StepInput, round_number: int = 0) -> StepOutput:
    """Run the Editor to approve or request revisions.

    Args:
        step_input: The input containing the draft article.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The editor's verdict (APPROVE or REVISE with comments).
    """
    draft = step_input.previous_step_outputs or step_input.input
    editor = build_editor()

    prompt = (
        "Revise o seguinte rascunho. Se estiver aceitável, responda apenas com 'APPROVE'.\n"
        "Caso contrário, responda 'REVISE' e liste correções específicas ou tarefas de pesquisa adicionais.\n\n"
        f"{draft}"
    )

    result = editor.run(prompt)

    # Extract only the content from RunOutput object
    verdict_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Editor",
        input_data=prompt,
        output_data=verdict_content,
        round_number=round_number,
        step="edit"
    )

    return StepOutput(content=verdict_content.strip())

def revision_loop(
    topic: str, max_rounds: int = 2
) -> str:
    """Execute revision loop with Editor feedback until approval or max rounds reached.

    The function orchestrates the multi-agent workflow:
    1. Researcher conducts web research and creates a brief
    2. Writer creates an article from the research brief
    3. Editor reviews and either approves or requests revisions
    4. If revisions requested, loop back to step 1 with editor feedback

    Args:
        topic: The research topic to investigate and write about.
        max_rounds: Maximum number of revision rounds (default: 2).

    Returns:
        str: The final article content in markdown format.
    """
    # 1) Initial research and write (round 0)
    research_out = research_step_fn(StepInput(input=topic), round_number=0).content
    draft_out = write_step_fn(StepInput(input=research_out), topic=topic, round_number=0).content
    verdict = edit_step_fn(StepInput(input=draft_out), round_number=0).content

    rounds = 0
    while rounds < max_rounds and verdict.upper().startswith("REVISE"):
        rounds += 1
        # Extract the editor's numbered requests and feed back to Researcher
        researcher = build_researcher()

        revision_prompt = (
            f"Tópico: {topic}\n"
            "Você deve atender às solicitações de revisão do Editor abaixo, encontrando informações confiáveis que faltam.\n"
            "Adicione novas fontes conforme necessário e atualize o relatório, preservando a numeração.\n\n"
            f"Solicitações do Editor:\n{verdict}\n\n"
            "Retorne o relatório de pesquisa ATUALIZADO."
        )

        updated_result = researcher.run(revision_prompt)
        updated_brief = updated_result.content if hasattr(updated_result, 'content') else str(updated_result)

        # Log revision research
        log_agent_execution(
            agent_name="Researcher",
            input_data=revision_prompt,
            output_data=updated_brief,
            round_number=rounds,
            step="revision_research"
        )

        # Rewrite with updated brief
        writer = build_writer()

        rewrite_prompt = (
            f"Reescreva o artigo sobre: {topic}\n"
            "Use este relatório de pesquisa ATUALIZADO e mantenha as citações consistentes. "
            "Se novas fontes foram adicionadas, estenda a numeração e inclua-as nas Fontes.\n\n"
            f"{updated_brief}"
        )

        draft_result = writer.run(rewrite_prompt)
        draft_out = draft_result.content if hasattr(draft_result, 'content') else str(draft_result)

        # Log revision writing
        log_agent_execution(
            agent_name="Writer",
            input_data=rewrite_prompt,
            output_data=draft_out,
            round_number=rounds,
            step="revision_write"
        )

        verdict = edit_step_fn(StepInput(input=draft_out), round_number=rounds).content

    # Return the best draft (even if Editor still wants tweaks after max rounds)
    return draft_out

def build_workflow() -> Workflow:
    """Build a single-pass workflow for research, writing, and editing.

    This creates a workflow with three sequential steps:
    1. Research step - Conducts web research
    2. Write step - Creates article from research
    3. Edit step - Reviews and validates the article

    Note: The main execution uses revision_loop instead for iterative improvement.

    Args:
        None

    Returns:
        Workflow: Configured workflow with research, write, and edit steps.
    """
    return Workflow(
        name="Research->Write->Edit",
        steps=[
            research_step_fn,
            Step(executor=write_step_fn, name="Write"),
            Step(executor=edit_step_fn, name="Edit"),
        ],
    )


# CLI
def run(topic: str) -> str:
    """Execute the complete multi-agent research and writing workflow.

    Orchestrates the full process of researching, writing, and editing
    an article on the given topic with up to 2 revision rounds.

    Args:
        topic: The topic to research and write about (str).

    Returns:
        str: The final article content in markdown format with sources.
    """
    return revision_loop(topic, max_rounds=2)

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python multi_agent_research.py \"<topic>\"")
        sys.exit(1)
    topic = sys.argv[1]
    article_md = run(topic)

    # Create timestamped output filename to keep history
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = Path(f"output_{timestamp}.md")
    output_file.write_text(article_md, encoding="utf-8")

    # Also create/update a 'latest.md' symlink or copy for convenience
    latest_file = Path("output_latest.md")
    latest_file.write_text(article_md, encoding="utf-8")

    print(f"Article saved to {output_file.absolute()}")
    print(f"Latest version: {latest_file.absolute()}")
