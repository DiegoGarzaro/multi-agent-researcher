"""Multi-agent research system for generating articles with web search.

This module orchestrates a multi-agent system that conducts web research,
writes articles, and performs editorial review with revision loops.
"""

import json
import os
from datetime import datetime
from pathlib import Path

from dotenv import load_dotenv

from agno.agent import Agent
from agno.team import Team
from agno.workflow import Workflow, Step, StepInput, StepOutput
from agno.models.openai import OpenAIChat

from agno.tools.duckduckgo import DuckDuckGoTools
from agno.tools.trafilatura import TrafilaturaTools

from ai_prompts import (
    RESEARCH_INSTRUCTIONS,
    WRITER_INSTRUCTIONS,
    TRANSLATOR_INSTRUCTIONS,
    EDITOR_INSTRUCTIONS
)

# Load environment variables from .env file
load_dotenv()

# Create agents_log directory if it doesn't exist
AGENTS_LOG_DIR = Path("agents_log")
AGENTS_LOG_DIR.mkdir(exist_ok=True)

# Load OpenAI model configurations from environment variables
RESEARCHER_MODEL = os.getenv("RESEARCHER_MODEL", "gpt-4o-mini")
WRITER_MODEL = os.getenv("WRITER_MODEL", "gpt-4o-mini")
TRANSLATOR_MODEL = os.getenv("TRANSLATOR_MODEL", "gpt-4o-mini")
EDITOR_MODEL = os.getenv("EDITOR_MODEL", "gpt-4o-mini")


def log_agent_execution(
    agent_name: str,
    input_data: str,
    output_data: str,
    round_number: int = 0,
    step: str = "initial"
) -> None:
    """Log agent execution details to a file in the agents_log directory.

    Args:
        agent_name: The name of the agent (e.g., "Researcher", "Writer", "Editor").
        input_data: The input provided to the agent.
        output_data: The output generated by the agent.
        round_number: The revision round number (0 for initial execution).
        step: The step identifier (e.g., "initial", "revision", "final").

    Returns:
        None
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"{timestamp}_{agent_name}_round{round_number}_{step}.json"
    log_path = AGENTS_LOG_DIR / log_filename

    log_data = {
        "timestamp": datetime.now().isoformat(),
        "agent_name": agent_name,
        "round_number": round_number,
        "step": step,
        "input": input_data,
        "output": output_data,
    }

    log_path.write_text(json.dumps(log_data, indent=2, ensure_ascii=False), encoding="utf-8")


# Agents
def build_researcher() -> Agent:
    """Build and configure the Researcher agent.

    The Researcher agent is responsible for conducting web searches and
    extracting reliable sources to create a research brief.

    The model used is configured via the RESEARCHER_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Researcher agent with web search and extraction tools.
    """
    tools = [
        DuckDuckGoTools(),
        TrafilaturaTools(),
    ]
    return Agent(
        name="Researcher",
        role="Web search & source extraction",
        model=OpenAIChat(id=RESEARCHER_MODEL),
        tools=tools,
        instructions=RESEARCH_INSTRUCTIONS,
        markdown=True,
    )


def build_writer() -> Agent:
    """Build and configure the Writer agent.

    The Writer agent transforms research briefs into compelling,
    persuasive articles using marketing techniques.

    The model used is configured via the WRITER_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Writer agent specialized in copywriting.
    """
    return Agent(
        name="Writer",
        role="Draft compelling, persuasive articles",
        model=OpenAIChat(id=WRITER_MODEL),
        instructions=WRITER_INSTRUCTIONS,
        markdown=True,
    )


def build_translator() -> Agent:
    """Build and configure the Translator agent.

    The Translator agent translates content from English to Portuguese (PT-BR)
    with natural, culturally-adapted language that maintains the original's
    persuasive tone.

    The model used is configured via the TRANSLATOR_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Translator agent specialized in EN to PT-BR translation.
    """
    return Agent(
        name="Translator",
        role="Translate content from English to Portuguese (PT-BR)",
        model=OpenAIChat(id=TRANSLATOR_MODEL),
        instructions=TRANSLATOR_INSTRUCTIONS,
        markdown=True,
    )


def build_editor() -> Agent:
    """Build and configure the Editor agent.

    The Editor agent reviews articles for accuracy, quality, marketing
    effectiveness, and PT-BR language compliance. It also routes work to
    the appropriate specialist agent (Researcher, Writer, or Translator).

    The model used is configured via the EDITOR_MODEL environment variable.
    Default: gpt-4o-mini

    Args:
        None

    Returns:
        Agent: Configured Editor agent for quality control and workflow routing.
    """
    return Agent(
        name="Editor",
        role="Review quality and route work to appropriate agents",
        model=OpenAIChat(id=EDITOR_MODEL),
        instructions=EDITOR_INSTRUCTIONS,
        markdown=True,
    )


# Workflow (orchestrator)
def assemble_team() -> Team:
    """Assemble a multi-agent team for research, writing, and translation tasks.

    Creates a team with Researcher, Writer, Translator, and Editor agents.
    The Editor acts as the workflow coordinator and routes work appropriately.

    Args:
        None

    Returns:
        Team: Configured team with all four agents (Researcher, Writer, Translator, Editor).
    """
    researcher = build_researcher()
    writer = build_writer()
    translator = build_translator()
    editor = build_editor()
    return Team(
        name="Research, Writing & Translation Team",
        members=[researcher, writer, translator, editor],
        # By default, the team leader coordinates; we'll still drive via Workflow.
        markdown=True,
    )

def research_step_fn(step_input: StepInput, round_number: int = 0) -> StepOutput:
    """Run the Researcher to produce a research brief.

    Args:
        step_input: The input containing the topic to research.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The research brief content.
    """
    topic = step_input.input
    researcher = build_researcher()

    prompt = (
        f"Tópico: {topic}\n"
        "Tarefa: Realize uma pesquisa profunda na web e produza o relatório de pesquisa conforme instruído."
    )

    result = researcher.run(prompt)

    # Extract only the content from RunOutput object
    brief_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Researcher",
        input_data=prompt,
        output_data=brief_content,
        round_number=round_number,
        step="research"
    )

    return StepOutput(content=brief_content)

def write_step_fn(step_input: StepInput, topic: str = "", round_number: int = 0) -> StepOutput:
    """Run the Writer to draft an article from the research brief.

    Args:
        step_input: The input containing the research brief.
        topic: The topic for the article.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The draft article content.
    """
    brief = step_input.previous_step_outputs or step_input.input
    writer = build_writer()

    prompt = (
        f"Write an article about: {topic}\n\n"
        f"Here is the research brief (use it strictly, maintain source numbering):\n\n{brief}"
    )

    result = writer.run(prompt)

    # Extract only the content from RunOutput object
    draft_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Writer",
        input_data=prompt,
        output_data=draft_content,
        round_number=round_number,
        step="write"
    )

    return StepOutput(content=draft_content)

def translator_step_fn(step_input: StepInput, round_number: int = 0) -> StepOutput:
    """Run the Translator to translate content to Portuguese (PT-BR).

    Args:
        step_input: The input containing the content to translate.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The translated content in PT-BR.
    """
    content = step_input.previous_step_outputs or step_input.input
    translator = build_translator()

    prompt = (
        "Translate the following content to Portuguese (PT-BR):\n\n"
        f"{content}"
    )

    result = translator.run(prompt)

    # Extract only the content from RunOutput object
    translated_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Translator",
        input_data=prompt,
        output_data=translated_content,
        round_number=round_number,
        step="translate"
    )

    return StepOutput(content=translated_content)

def edit_step_fn(step_input: StepInput, round_number: int = 0) -> StepOutput:
    """Run the Editor to approve or request revisions.

    Args:
        step_input: The input containing the draft article.
        round_number: The revision round number (0 for initial execution).

    Returns:
        StepOutput: The editor's verdict (APPROVE or REVISE with comments).
    """
    draft = step_input.previous_step_outputs or step_input.input
    editor = build_editor()

    prompt = (
        "Revise o seguinte rascunho. Se estiver aceitável, responda apenas com 'APPROVE'.\n"
        "Caso contrário, responda 'REVISE' e liste correções específicas ou tarefas de pesquisa adicionais.\n\n"
        f"{draft}"
    )

    result = editor.run(prompt)

    # Extract only the content from RunOutput object
    verdict_content = result.content if hasattr(result, 'content') else str(result)

    # Log the execution
    log_agent_execution(
        agent_name="Editor",
        input_data=prompt,
        output_data=verdict_content,
        round_number=round_number,
        step="edit"
    )

    return StepOutput(content=verdict_content.strip())

def revision_loop(
    topic: str, max_rounds: int = 2
) -> str:
    """Execute revision loop with Editor feedback until approval or max rounds reached.

    The function orchestrates the multi-agent workflow:
    1. Researcher conducts web research and creates a brief
    2. Writer creates an article from the research brief (in English)
    3. Translator translates the article to Portuguese (PT-BR)
    4. Editor reviews and either approves or routes to appropriate agent
    5. If routing requested, execute the specific agent and continue loop

    Args:
        topic: The research topic to investigate and write about.
        max_rounds: Maximum number of revision rounds (default: 2).

    Returns:
        str: The final article content in markdown format (PT-BR).
    """
    # 1) Initial research, write, and translate (round 0)
    research_out = research_step_fn(StepInput(input=topic), round_number=0).content
    draft_out = write_step_fn(StepInput(input=research_out), topic=topic, round_number=0).content
    translated_out = translator_step_fn(StepInput(input=draft_out), round_number=0).content
    verdict = edit_step_fn(StepInput(input=translated_out), round_number=0).content

    rounds = 0
    while rounds < max_rounds and not verdict.upper().startswith("APPROVE"):
        rounds += 1

        # Parse the routing decision from the editor
        if verdict.upper().startswith("ROUTE_TO_RESEARCHER"):
            # Route to Researcher for additional research
            researcher = build_researcher()

            revision_prompt = (
                f"Topic: {topic}\n"
                "You need to address the Editor's revision requests below by finding missing reliable information.\n"
                "Add new sources as needed and update the brief, preserving source numbering.\n\n"
                f"Editor's Requests:\n{verdict}\n\n"
                "Return the UPDATED research brief."
            )

            updated_result = researcher.run(revision_prompt)
            research_out = updated_result.content if hasattr(updated_result, 'content') else str(updated_result)

            # Log revision research
            log_agent_execution(
                agent_name="Researcher",
                input_data=revision_prompt,
                output_data=research_out,
                round_number=rounds,
                step="revision_research"
            )

            # Rewrite with updated brief
            draft_out = write_step_fn(StepInput(input=research_out), topic=topic, round_number=rounds).content

            # Translate the updated draft
            translated_out = translator_step_fn(StepInput(input=draft_out), round_number=rounds).content

        elif verdict.upper().startswith("ROUTE_TO_WRITER"):
            # Route to Writer for content improvements
            writer = build_writer()

            rewrite_prompt = (
                f"Rewrite the article about: {topic}\n"
                "Address the Editor's feedback below. Maintain citation consistency. "
                "If new sources were added, extend the numbering and include them in Sources.\n\n"
                f"Editor's Feedback:\n{verdict}\n\n"
                f"Research Brief:\n{research_out}\n\n"
                f"Previous Draft:\n{draft_out}"
            )

            draft_result = writer.run(rewrite_prompt)
            draft_out = draft_result.content if hasattr(draft_result, 'content') else str(draft_result)

            # Log revision writing
            log_agent_execution(
                agent_name="Writer",
                input_data=rewrite_prompt,
                output_data=draft_out,
                round_number=rounds,
                step="revision_write"
            )

            # Translate the updated draft
            translated_out = translator_step_fn(StepInput(input=draft_out), round_number=rounds).content

        elif verdict.upper().startswith("ROUTE_TO_TRANSLATOR"):
            # Route to Translator for translation improvements
            translator = build_translator()

            retranslate_prompt = (
                "Retranslate the following content to Portuguese (PT-BR).\n"
                "Address the Editor's feedback below:\n\n"
                f"Editor's Feedback:\n{verdict}\n\n"
                f"Original English Content:\n{draft_out}"
            )

            translate_result = translator.run(retranslate_prompt)
            translated_out = translate_result.content if hasattr(translate_result, 'content') else str(translate_result)

            # Log revision translation
            log_agent_execution(
                agent_name="Translator",
                input_data=retranslate_prompt,
                output_data=translated_out,
                round_number=rounds,
                step="revision_translate"
            )

        else:
            # Unrecognized routing command, break to avoid infinite loop
            print(f"Warning: Unrecognized editor response: {verdict[:100]}")
            break

        # Get editor's verdict on the updated content
        verdict = edit_step_fn(StepInput(input=translated_out), round_number=rounds).content

    # Return the final translated draft (even if Editor still wants tweaks after max rounds)
    return translated_out

def build_workflow() -> Workflow:
    """Build a single-pass workflow for research, writing, translation, and editing.

    This creates a workflow with four sequential steps:
    1. Research step - Conducts web research
    2. Write step - Creates article from research (in English)
    3. Translate step - Translates article to Portuguese (PT-BR)
    4. Edit step - Reviews and validates the article

    Note: The main execution uses revision_loop instead for iterative improvement.

    Args:
        None

    Returns:
        Workflow: Configured workflow with research, write, translate, and edit steps.
    """
    return Workflow(
        name="Research->Write->Translate->Edit",
        steps=[
            research_step_fn,
            Step(executor=write_step_fn, name="Write"),
            Step(executor=translator_step_fn, name="Translate"),
            Step(executor=edit_step_fn, name="Edit"),
        ],
    )


# CLI
def run(topic: str) -> str:
    """Execute the complete multi-agent research and writing workflow.

    Orchestrates the full process of researching, writing, and editing
    an article on the given topic with up to 2 revision rounds.

    Args:
        topic: The topic to research and write about (str).

    Returns:
        str: The final article content in markdown format with sources.
    """
    return revision_loop(topic, max_rounds=2)

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python multi_agent_research.py \"<topic>\"")
        sys.exit(1)
    topic = sys.argv[1]
    article_md = run(topic)

    # Create timestamped output filename to keep history
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = Path(f"output_{timestamp}.md")
    output_file.write_text(article_md, encoding="utf-8")

    # Also create/update a 'latest.md' symlink or copy for convenience
    latest_file = Path("output_latest.md")
    latest_file.write_text(article_md, encoding="utf-8")

    print(f"Article saved to {output_file.absolute()}")
    print(f"Latest version: {latest_file.absolute()}")
